// Copyright 2017 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef LIB_ESCHER_IMPL_SSDO_ACCELERATOR_H_
#define LIB_ESCHER_IMPL_SSDO_ACCELERATOR_H_

#include <vulkan/vulkan.hpp>

#include "lib/escher/forward_declarations.h"
#include "lib/fxl/macros.h"

namespace escher {
namespace impl {

// The purpose of this class is to generate a lookup table that can decide
// whether SSDO sampling/filtering can be skipped for a given pixel.
class SsdoAccelerator {
 public:
  SsdoAccelerator(EscherWeakPtr escher, ImageFactory* image_factory);
  ~SsdoAccelerator();

  // Generates a packed lookup table to accelerate SSDO sampling/filtering.
  // 2 bits of information are computed for each pixel of the input depth image;
  // these indicate whether SSDO sampling and/or filtering is required for that
  // pixel.
  //
  // To reduce memory bandwidth requirements, the information for a 4x4
  // region of the depth image is packed into a single 32-bit RGBA pixel.
  // Each row of the input region is stored into a single 8-bit channel, e.g.
  // the red channel represents row0.  Within each channel, the leftmost result
  // is stored in the 2 least-significant bits, and the rightmost in the 2 most
  // significant bits.  Of each pair of bits, the less-significant one indicates
  // whether SSDO sampling is required, and the other indicates whether SSDO
  // filtering is required.
  TexturePtr GenerateLookupTable(const FramePtr& frame,
                                 const TexturePtr& depth_texture,
                                 vk::ImageUsageFlags image_flags);

  // Unpack the image generated by GenerateLookupTable(), or another image with
  // the same packed format, into an image 4x larger in each dimension, suitable
  // for debug visualization.  For each ouput pixel, the corresponding pair of
  // packed bits determine the red and green values.  For example, if the less-
  // significant of the packed bits is 1, then the red channel is set to 1.0,
  // otherwise 0.0.
  TexturePtr UnpackLookupTable(const FramePtr& frame,
                               const TexturePtr& packed_lookup_table,
                               uint32_t output_width, uint32_t output_height);

  bool enabled() const { return enabled_; }
  void set_enabled(bool enabled) { enabled_ = enabled; }

 private:
  const VulkanContext& vulkan_context() const;

  // Return a lookup table in the same format defined by GenerateLookupTable(),
  // where every pixel is considered to be potentially-shadowed.
  TexturePtr GenerateNullLookupTable(const FramePtr& frame,
                                     const TexturePtr& depth_texture,
                                     vk::ImageUsageFlags image_flags);

  const EscherWeakPtr escher_;
  ImageFactory* const image_factory_;

  // Used by GenerateLookupTable().
  std::unique_ptr<ComputeShader> kernel_;
  // Used by GenerateNullLookupTable().
  std::unique_ptr<ComputeShader> null_kernel_;
  // Used by UnpackLookupTable() to unpack an image in the same format as
  // generated by GenerateLookupTable().
  std::unique_ptr<ComputeShader> unpack_kernel_;

  // If |enabled| is false, calls GenerateNullLookupTable(), which has
  // negligible cost.
  bool enabled_ = true;

  FXL_DISALLOW_COPY_AND_ASSIGN(SsdoAccelerator);
};

}  // namespace impl
}  // namespace escher

#endif  // LIB_ESCHER_IMPL_SSDO_ACCELERATOR_H_
