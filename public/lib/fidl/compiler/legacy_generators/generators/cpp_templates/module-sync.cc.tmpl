{%- import "interface_macros.tmpl" as interface_macros -%}
{%- import "struct_macros.tmpl" as struct_macros -%}

// NOTE: This file was generated by the Mojo bindings generator.
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "{{module.path}}-sync.h"

#include <math.h>
#include <ostream>
#include <string>
#include <utility>

#include "lib/fidl/cpp/bindings/internal/array_serialization.h"
#include "lib/fidl/cpp/bindings/internal/bindings_serialization.h"
#include "lib/fidl/cpp/bindings/internal/bounds_checker.h"
#include "lib/fidl/cpp/bindings/internal/map_data_internal.h"
#include "lib/fidl/cpp/bindings/internal/map_serialization.h"
#include "lib/fidl/cpp/bindings/internal/message_builder.h"
#include "lib/fidl/cpp/bindings/internal/message_validation.h"
#include "lib/fidl/cpp/bindings/internal/string_serialization.h"
#include "lib/fidl/cpp/bindings/internal/validate_params.h"
#include "lib/fidl/cpp/bindings/internal/validation_errors.h"
#include "lib/fidl/cpp/bindings/internal/validation_util.h"
#include "lib/fidl/cpp/bindings/message.h"
#include "lib/fidl/cpp/bindings/message_validator.h"
#include "lib/fxl/logging.h"
#include "{{module.path}}-internal.h"
#include "{{module.path}}-common.h"

{%- for namespace in namespaces_as_array %}
namespace {{namespace}} {
{%- endfor %}

// --- Interface definitions ---
{% for interface in interfaces %}
{%- set base_name = "internal::%s_Base"|format(interface.name) -%}
{{interface.name}}_SynchronousProxy::{{interface.name}}_SynchronousProxy(
      ::zx::channel channel,
      ::f1dl::internal::MessageValidatorList&& validators)
          : channel_(std::move(channel)), validators_(std::move(validators)) {
}

zx::channel {{interface.name}}_SynchronousProxy::TakeChannel_() {
  return std::move(channel_);
}

{% for method in interface.methods %}
{%-   set message_name =
          "%s::MessageOrdinals::%s"|format(base_name, method.name) %}
{%-   set params_struct = method.param_struct %}
{%-   set params_description =
          "%s.%s request"|format(interface.name, method.name) %}
bool {{interface.name}}_SynchronousProxy::{{method.name}}(
    {{- interface_macros.declare_sync_request_params(method)}})
    {%- if method.response_parameters == None %} const {% endif %} {
  {{struct_macros.get_serialized_size(params_struct, "in_%s")}}

  auto msg_name = static_cast<uint32_t>({{message_name}});
{%-   if method.response_parameters != None %}
  ::f1dl::RequestMessageBuilder builder(msg_name, size);
{%-   else %}
  ::f1dl::MessageBuilder builder(msg_name, size);
{%-   endif %}

  {{struct_macros.serialize(params_struct,
                            "{{interface.name}}::{{method.name}}", "in_%s",
                            "out_params", "builder.buffer()", false)}}
  out_params->EncodePointersAndHandles(builder.message()->mutable_handles());

{%-   if method.response_parameters == None %}
  if (::f1dl::WriteMessage(channel_, builder.message()) != ZX_OK)
    return false;

{%-   else %}
  ::f1dl::PreallocMessage response_msg;
  if (::f1dl::CallMessage(channel_, builder.message(), &response_msg)
      != ZX_OK) {
    return false;
  }

  // Validate the incoming message.
  std::string response_err;
  if (::f1dl::internal::RunValidatorsOnMessage(validators_, &response_msg,
                                               &response_err)
        != ::f1dl::internal::ValidationError::NONE) {
    return false;
  }

{#- TODO(vardhan): Add support for synchronous control messages. #}
  if (response_msg.name() != msg_name) {
    return false;
  }

  internal::{{interface.name}}_{{method.name}}_ResponseParams_Data*
      response_params = reinterpret_cast<internal::{{interface.name}}_{{method.name}}_ResponseParams_Data*>(
          response_msg.mutable_payload());
  response_params->DecodePointersAndHandles(response_msg.mutable_handles());

  {{struct_macros.deserialize(method.response_param_struct, "response_params",
                              "(*out_%s)")}}
{%-   endif %}
  return true;
}
{%- endfor %}
{%- endfor %}

{%- for namespace in namespaces_as_array|reverse %}
}  // namespace {{namespace}}
{%- endfor %}

#if defined(__clang__)
#pragma clang diagnostic pop
#endif
